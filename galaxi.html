<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Singularity Romántico</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono:wght@400;700&family=Georgia:ital@0;1&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #100518 0%, #020104 70%);
            color: #00ffcc;
            font-family: 'Share Tech Mono', monospace;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 105, 180, 0.9);
            font-family: 'Georgia', serif;
            font-size: 22px;
            font-style: italic;
            letter-spacing: 1px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 0 8px rgba(255, 105, 180, 0.7), 0 0 12px rgba(255, 105, 180, 0.5), 2px 2px 4px rgba(0,0,0,0.8);
            transition: opacity 2s ease-in-out 1s;
            background: linear-gradient(135deg, rgba(255, 20, 147, 0.3), rgba(138, 43, 226, 0.3));
            padding: 20px 40px;
            border-radius: 25px;
            border: 2px solid rgba(255, 182, 193, 0.4);
            backdrop-filter: blur(10px);
            margin: 0 20px;
        }
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        #info {
            animation: float 3s ease-in-out infinite;
        }
        @media (max-width: 640px) {
            #info { font-size: 18px; top: 15px; padding: 15px 30px; }
            #info span {
                font-size: 11px !important;
            }
            .progress-bar { width: 250px; }
            #status { font-size: 10px; padding: 6px; }
        }
        /* Estilos para la carga */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #100518 0%, #020104 70%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            transition: opacity 0.5s ease-out;
        }
        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .progress-bar {
            width: 300px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ffcc;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 150;
            font-family: 'Share Tech Mono', monospace;
            border: 1px solid #00ffcc;
        }
    </style>
</head>
<body>
    <div id="info">
        <br>
        <span style="font-size: 14px; opacity: 0.8; font-family: 'Share Tech Mono', monospace;">Puedes hacer zoom en la pantalla para ver la magia</span>
    </div>
    <div id="status">Verificando...</div>
    <div id="loading">
        <div style="color: #ff00ff; font-size: 24px; margin-bottom: 20px;">Cargando Galaxia de Amor...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
    </div>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
      }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;

        // Configuración de la singularidad cyberpunk (fondo)
        const BLACK_HOLE_RADIUS = 1.3;
        const DISK_INNER_RADIUS = BLACK_HOLE_RADIUS + 0.2;
        const DISK_OUTER_RADIUS = 8.0;
        const DISK_TILT_ANGLE = Math.PI / 3.0;

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020104, 0.035);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000);
        camera.position.set(isMobile ? -12 : -6.5, isMobile ? 8 : 5.0, isMobile ? 12 : 6.5);

        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(isMobile ? 1 : 1.5);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            isMobile ? 0.4 : 0.6, 0.7, 0.2
        );
        composer.addPass(bloomPass);

        const lensingShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "blackHoleScreenPos": { value: new THREE.Vector2(0.5, 0.5) },
                "lensingStrength": { value: 0.12 }, "lensingRadius": { value: 0.3 },
                "aspectRatio": { value: window.innerWidth / window.innerHeight },
                "chromaticAberration": { value: 0.015 }, "scanlineIntensity": { value: 0.0 },
                "vignetteDarkness": { value: 0.8 }
            },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `
                uniform sampler2D tDiffuse; uniform vec2 blackHoleScreenPos; uniform float lensingStrength;
                uniform float lensingRadius; uniform float aspectRatio; uniform float chromaticAberration;
                uniform float scanlineIntensity; uniform float vignetteDarkness; varying vec2 vUv;
                void main() {
                    vec2 screenPos = vUv; vec2 toCenter = screenPos - blackHoleScreenPos;
                    toCenter.x *= aspectRatio; float dist = length(toCenter);
                    float distortionAmount = lensingStrength / (dist * dist + 0.003);
                    distortionAmount = clamp(distortionAmount, 0.0, 0.7);
                    float falloff = smoothstep(lensingRadius, lensingRadius * 0.3, dist);
                    distortionAmount *= falloff; vec2 offset = normalize(toCenter) * distortionAmount;
                    offset.x /= aspectRatio; vec2 distortedUvR = screenPos - offset * (1.0 + chromaticAberration);
                    vec2 distortedUvG = screenPos - offset; vec2 distortedUvB = screenPos - offset * (1.0 - chromaticAberration);
                    float r = texture2D(tDiffuse, distortedUvR).r; float g = texture2D(tDiffuse, distortedUvG).g;
                    float b = texture2D(tDiffuse, distortedUvB).b; vec3 finalColor = vec3(r, g, b);
                    float scanline = sin(vUv.y * 800.0) * 0.5 + 0.5;
                    finalColor.rgb -= scanline * scanlineIntensity * finalColor.rgb;
                    float vignette = length(vUv - vec2(0.5)); finalColor *= (1.0 - vignette * vignetteDarkness);
                    gl_FragColor = vec4(finalColor, 1.0);
                }`
        };
        const lensingPass = new ShaderPass(lensingShader);
        composer.addPass(lensingPass);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.035;
        controls.rotateSpeed = 0.4; controls.autoRotate = false;
        controls.autoRotateSpeed = 0.1; controls.target.set(0, 0, 0);
        controls.minDistance = 2.5; controls.maxDistance = 100;
        controls.enablePan = false;
        controls.update();

        // Elementos de la galaxia cyberpunk (fondo)
        const starGeometry = new THREE.BufferGeometry();
        const starCount = isMobile ? 80000 : 150000;
        const starPositions = new Float32Array(starCount * 3);
        const starColors = new Float32Array(starCount * 3);
        const starSizes = new Float32Array(starCount);
        const starTwinkle = new Float32Array(starCount);
        const starFieldRadius = 2000;
        const starPalette = [
            new THREE.Color(0x00ffff), new THREE.Color(0xff00ff),
            new THREE.Color(0x8A2BE2), new THREE.Color(0x00ff7f),
            new THREE.Color(0xccddff),
        ];
        for (let i = 0; i < starCount; i++) {
            const i3 = i * 3;
            const phi = Math.acos(-1 + (2 * i) / starCount);
            const theta = Math.sqrt(starCount * Math.PI) * phi;
            const radius = Math.cbrt(Math.random()) * starFieldRadius + 100;
            starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
            starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            starPositions[i3 + 2] = radius * Math.cos(phi);
            const starColor = starPalette[Math.floor(Math.random() * starPalette.length)].clone();
            starColor.multiplyScalar(Math.random() * 0.7 + 0.3);
            starColors[i3] = starColor.r; starColors[i3 + 1] = starColor.g; starColors[i3 + 2] = starColor.b;
            starSizes[i] = THREE.MathUtils.randFloat(0.8, 2.5);
            starTwinkle[i] = Math.random() * Math.PI * 2;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
        starGeometry.setAttribute('twinkle', new THREE.BufferAttribute(starTwinkle, 1));

        const starMaterial = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uPixelRatio: { value: renderer.getPixelRatio() } },
            vertexShader: `
                uniform float uTime; uniform float uPixelRatio;
                attribute float size; attribute float twinkle;
                varying vec3 vColor; varying float vTwinkle;
                void main() {
                    vColor = color; vTwinkle = sin(uTime * 2.5 + twinkle) * 0.5 + 0.5;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * uPixelRatio * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }`,
            fragmentShader: `
                varying vec3 vColor; varying float vTwinkle;
                void main() {
                    float dist = distance(gl_PointCoord, vec2(0.5));
                    float cross = abs(gl_PointCoord.x - 0.5) + abs(gl_PointCoord.y - 0.5);
                    if (cross > 0.5) discard;
                    float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                    alpha *= (0.2 + vTwinkle * 0.8);
                    gl_FragColor = vec4(vColor, alpha);
                }`,
            transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        const eventHorizonGeom = new THREE.SphereGeometry(BLACK_HOLE_RADIUS * 1.05, 128, 64);
        const eventHorizonMat = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uCameraPosition: { value: camera.position } },
            vertexShader: `
                varying vec3 vNormal; varying vec3 vPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal); vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform float uTime; uniform vec3 uCameraPosition;
                varying vec3 vNormal; varying vec3 vPosition;
                void main() {
                    vec3 viewDirection = normalize(uCameraPosition - vPosition);
                    float fresnel = 1.0 - abs(dot(vNormal, viewDirection));
                    fresnel = pow(fresnel, 2.0); vec3 glowColor = vec3(0.0, 1.0, 0.8);
                    float pulse = sin(uTime * 3.5) * 0.2 + 0.8;
                    gl_FragColor = vec4(glowColor * fresnel * pulse, fresnel * 0.5);
                }`,
            transparent: true, blending: THREE.AdditiveBlending, side: THREE.BackSide
        });
        const eventHorizon = new THREE.Mesh(eventHorizonGeom, eventHorizonMat);
        scene.add(eventHorizon);

        const blackHoleGeom = new THREE.SphereGeometry(BLACK_HOLE_RADIUS, 128, 64);
        const blackHoleMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const blackHoleMesh = new THREE.Mesh(blackHoleGeom, blackHoleMat);
        blackHoleMesh.renderOrder = 0;
        scene.add(blackHoleMesh);

        // Create heart-shaped disk
        function createHeartShape(scale, offsetX, offsetY) {
            const shape = new THREE.Shape();
            shape.moveTo(offsetX + 5 * scale, offsetY + 5 * scale);
            shape.bezierCurveTo(offsetX + 5 * scale, offsetY + 5 * scale, offsetX + 4 * scale, offsetY, offsetX, offsetY);
            shape.bezierCurveTo(offsetX - 6 * scale, offsetY, offsetX - 6 * scale, offsetY + 7 * scale, offsetX - 6 * scale, offsetY + 7 * scale);
            shape.bezierCurveTo(offsetX - 6 * scale, offsetY + 11 * scale, offsetX - 3 * scale, offsetY + 15.4 * scale, offsetX + 5 * scale, offsetY + 19 * scale);
            shape.bezierCurveTo(offsetX + 12 * scale, offsetY + 15.4 * scale, offsetX + 16 * scale, offsetY + 11 * scale, offsetX + 16 * scale, offsetY + 7 * scale);
            shape.bezierCurveTo(offsetX + 16 * scale, offsetY + 7 * scale, offsetX + 16 * scale, offsetY, offsetX + 10 * scale, offsetY);
            shape.bezierCurveTo(offsetX + 7 * scale, offsetY, offsetX + 5 * scale, offsetY + 5 * scale, offsetX + 5 * scale, offsetY + 5 * scale);
            return shape;
        }

        const outerScale = DISK_OUTER_RADIUS / 16;
        const innerScale = DISK_INNER_RADIUS / 16;
        const centerX = -5 * outerScale;
        const centerY = -9.5 * outerScale;

        const outerHeart = createHeartShape(outerScale, centerX, centerY);
        const innerHeart = createHeartShape(innerScale, -5 * innerScale + centerX * (innerScale / outerScale), -9.5 * innerScale + centerY * (innerScale / outerScale));
        outerHeart.holes.push(innerHeart);

        const diskGeometry = new THREE.ShapeGeometry(outerHeart);

        const diskMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0.0 }, uColorHot: { value: new THREE.Color(0xffffff) },
                uColorMid1: { value: new THREE.Color(0xff00ff) }, uColorMid2: { value: new THREE.Color(0x00ffff) },
                uColorOuter: { value: new THREE.Color(0x3939f5) }, uNoiseScale: { value: 3.5 },
                uFlowSpeed: { value: 0.25 }, uDensity: { value: 1.5 }
            },
            vertexShader: `
                varying vec2 vUv; varying float vRadius; varying float vAngle;
                void main() {
                    vUv = uv; vRadius = length(position.xy); vAngle = atan(position.y, position.x);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform float uTime; uniform vec3 uColorHot; uniform vec3 uColorMid1; uniform vec3 uColorMid2; uniform vec3 uColorOuter;
                uniform float uNoiseScale; uniform float uFlowSpeed; uniform float uDensity;
                varying vec2 vUv; varying float vRadius; varying float vAngle;
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                float snoise(vec3 v) {
                    const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx);
                    vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy);
                    vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy;
                    i = mod289(i); vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                    float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_); vec4 x = x_ * ns.x + ns.yyyy; vec4 y = y_ * ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw);
                    vec4 s0 = floor(b0) * 2.0 + 1.0; vec4 s1 = floor(b1) * 2.0 + 1.0; vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
                    vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
                    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
                    m = m * m; return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
                }
                void main() {
                    float normalizedRadius = smoothstep(${DISK_INNER_RADIUS.toFixed(2)}, ${DISK_OUTER_RADIUS.toFixed(2)}, vRadius);
                    float timeOffset = uTime * uFlowSpeed * (2.0 / (vRadius * 0.3 + 1.0));
                    vec2 noiseUv = vec2(vAngle * 2.0 + timeOffset, vRadius * 0.5);
                    float noiseVal1 = snoise(vec3(noiseUv * uNoiseScale, uTime * 0.15));
                    float noiseVal2 = snoise(vec3(noiseUv * uNoiseScale * 2.0 + 0.8, uTime * 0.22));
                    float noiseVal = (noiseVal1 * 0.6 + noiseVal2 * 0.4); noiseVal = (noiseVal + 1.0) * 0.5;
                    vec3 color = mix(uColorOuter, uColorMid2, smoothstep(0.0, 0.4, normalizedRadius));
                    color = mix(color, uColorMid1, smoothstep(0.3, 0.7, normalizedRadius));
                    color = mix(color, uColorHot, smoothstep(0.65, 0.95, normalizedRadius));
                    float brightness = pow(1.0 - normalizedRadius, 1.2) * 3.0 + 0.5;
                    brightness *= (0.3 + noiseVal * 2.2);
                    float radialGrid = 1.0 - (sin(vRadius * 3.0 - uTime * 0.5) * 0.5 + 0.5);
                    radialGrid = pow(radialGrid, 4.0); float angleGrid = 1.0 - (sin(vAngle * 20.0) * 0.5 + 0.5);
                    angleGrid = pow(angleGrid, 4.0); float grid = 1.0 - clamp(radialGrid + angleGrid, 0.0, 1.0);
                    brightness *= (0.7 + grid * 0.8); float alpha = uDensity * (0.2 + noiseVal * 0.9);
                    alpha *= smoothstep(0.0, 0.15, normalizedRadius); alpha *= (1.0 - smoothstep(0.85, 1.0, normalizedRadius));
                    alpha = clamp(alpha, 0.0, 1.0); gl_FragColor = vec4(color * brightness, alpha);
                }`,
            transparent: true, side: THREE.DoubleSide, depthWrite: false, blending: THREE.AdditiveBlending
        });
        const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
        accretionDisk.rotation.x = DISK_TILT_ANGLE;
        accretionDisk.renderOrder = 1;
        scene.add(accretionDisk);

        const gridHelper = new THREE.GridHelper(100, 50, 0x00ffff, 0x00ffff);
        gridHelper.material.opacity = 0.1;
        gridHelper.material.transparent = true;
        gridHelper.material.blending = THREE.AdditiveBlending;
        gridHelper.position.y = -10;
        scene.add(gridHelper);

        // Elementos románticos (frente) - Adaptados a la escena
        let particles = [];
        let imageParticles = [];
        let hearts = [];
        let time = 0;
        const romanticEmojis = ['💕', '💖', '💗', '💓', '💝', '💘', '💞', '❤️', '🖤', '🤍',
                                '💜', '🩷', '❣️'];
        const romanticPhrases = [
            'Te amo', 'Te quiero', 'Eres mi todo', 'Mi amor', 'Para siempre',
            'Juntos', 'Mi vida', 'Amor eterno', 'Mi cielo', 'Contigo',
            'Forever', 'Mi corazón', 'Te adoro', 'Mi mundo', 'Amor mío',
            'Eres único', 'Mi tesoro', 'Te necesito', 'Mi alma', 'Solo tú'
        ];
        const romanticColors = [0xff1493, 0xff69b4, 0xffc0cb, 0xffb6c1, 0xff85c1,
                                0xda70d6, 0xee82ee, 0xdda0dd, 0xf0e68c, 0xffd700];

        function createRomanticParticle() {
            const size = isMobile ? 100 : 140;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const isEmoji = Math.random() > 0.4;
           
            if (isEmoji) {
                ctx.shadowBlur = isMobile ? 20 : 30;
                ctx.shadowColor = 'rgba(255, 105, 180, 1.0)';
                ctx.font = `bold ${isMobile ? 70 : 100}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(romanticEmojis[Math.floor(Math.random() * romanticEmojis.length)], size / 2, size / 2);
            } else {
                ctx.shadowBlur = isMobile ? 15 : 25;
                ctx.shadowColor = 'rgba(255, 182, 193, 1.0)';
               
                const gradient = ctx.createLinearGradient(0, 0, size, size);
                gradient.addColorStop(0, '#' + romanticColors[Math.floor(Math.random() * romanticColors.length)].toString(16).padStart(6, '0'));
                gradient.addColorStop(1, '#' + romanticColors[Math.floor(Math.random() * romanticColors.length)].toString(16).padStart(6, '0'));
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);
               
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = isMobile ? 15 : 25;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.font = `italic bold ${isMobile ? 18 : 28}px Georgia, serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
               
                const phrase = romanticPhrases[Math.floor(Math.random() * romanticPhrases.length)];
                const words = phrase.split(' ');
               
                if (words.length > 2) {
                    ctx.fillText(words[0] + ' ' + words[1], size / 2, size * 0.43);
                    ctx.fillText(words.slice(2).join(' '), size / 2, size * 0.64);
                } else if (words.length === 2) {
                    ctx.fillText(words[0], size / 2, size * 0.43);
                    ctx.fillText(words[1], size / 2, size * 0.64);
                } else {
                    ctx.font = `italic bold ${isMobile ? 22 : 34}px Georgia, serif`;
                    ctx.fillText(phrase, size / 2, size / 2);
                }
               
                ctx.font = `${isMobile ? 18 : 25}px Arial`;
                ctx.shadowBlur = 8;
                ctx.fillText('💕', size / 2, size * 0.82);
            }
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(material);
            sprite.position.x = Math.random() * 120 - 60;
            sprite.position.y = Math.random() * 100 + 80;
            sprite.position.z = Math.random() * 120 - 60;
            const scale = isMobile ? (Math.random() * 4 + 3) : (Math.random() * 8 + 6);
            sprite.scale.set(scale, scale, 1);
            sprite.userData = {
                velocity: Math.random() * 0.05 + 0.02,
                rotationSpeed: (Math.random() - 0.5) * 0.02,
                swing: Math.random() * Math.PI * 2,
                swingSpeed: Math.random() * 0.02 + 0.015
            };
            scene.add(sprite);
            particles.push(sprite);
        }

        function createImageParticle() {
            if (typeof window.customImages === 'undefined' || window.customImages.length === 0) return;
            const size = isMobile ? 100 : 140;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, size, size);
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(material);
            sprite.position.x = Math.random() * 120 - 60;
            sprite.position.y = Math.random() * 100 + 80;
            sprite.position.z = Math.random() * 120 - 60;
            const scale = isMobile ? (Math.random() * 4 + 3) : (Math.random() * 8 + 6);
            sprite.scale.set(scale, scale, 1);
            sprite.userData = {
                velocity: Math.random() * 0.05 + 0.02,
                rotationSpeed: (Math.random() - 0.5) * 0.02,
                swing: Math.random() * Math.PI * 2,
                swingSpeed: Math.random() * 0.02 + 0.015,
                imgIndex: Math.floor(Math.random() * window.customImages.length)
            };
            sprite.material.map = window.customImages[sprite.userData.imgIndex];
            sprite.material.needsUpdate = true;
            scene.add(sprite);
            imageParticles.push(sprite);
        }

        window.createImages = function() {
            const imageCount = isMobile ? 5 : 10;
            for (let i = 0; i < imageCount; i++) {
                createImageParticle();
            }
        };

        function createFloatingHeart() {
            const size = isMobile ? 70 : 100;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.shadowBlur = isMobile ? 20 : 35;
            ctx.shadowColor = 'rgba(255, 20, 147, 1)';
            ctx.font = `bold ${isMobile ? 55 : 80}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('💖', size / 2, size / 2);
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(material);
            const angle = Math.random() * Math.PI * 2;
            const radius = 40 + Math.random() * 20;
            sprite.position.x = Math.cos(angle) * radius;
            sprite.position.y = Math.random() * 40 - 20;
            sprite.position.z = Math.sin(angle) * radius;
            const scale = isMobile ? (Math.random() * 4 + 3) : (Math.random() * 8 + 6);
            sprite.scale.set(scale, scale, 1);
            sprite.userData = {
                angle: angle,
                radius: radius,
                speed: 0.003 + Math.random() * 0.002,
                floatSpeed: Math.random() * 0.03 + 0.015,
                floatOffset: Math.random() * Math.PI * 2
            };
            scene.add(sprite);
            hearts.push(sprite);
        }

        function createMagicalStars() {
            const starCount = isMobile ? 1500 : 3000;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            for (let i = 0; i < starCount; i++) {
                vertices.push(
                    Math.random() * 500 - 250,
                    Math.random() * 500 - 250,
                    Math.random() * 500 - 250
                );
               
                const color = new THREE.Color();
                color.setHex(romanticColors[Math.floor(Math.random() * romanticColors.length)]);
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
           
            const material = new THREE.PointsMaterial({
                size: isMobile ? 1.5 : 2.0,
                transparent: true,
                opacity: 1.0,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
           
            const romanticStars = new THREE.Points(geometry, material);
            scene.add(romanticStars);
        }

        // Crear elementos románticos
        const particleCount = isMobile ? 200 : 400;
        const heartCount = isMobile ? 25 : 50;
        for (let i = 0; i < particleCount; i++) {
            createRomanticParticle();
        }
        for (let i = 0; i < heartCount; i++) {
            createFloatingHeart();
        }
        createMagicalStars();
        window.customImages = [];
        window.createImages();

        // Luces románticas
        const ambientLight = new THREE.AmbientLight(0xffe4f0, 0.6);
        scene.add(ambientLight);
        const pointLight1 = new THREE.PointLight(0xff1493, 3, 100);
        pointLight1.position.set(30, 30, 30);
        scene.add(pointLight1);
        const pointLight2 = new THREE.PointLight(0xda70d6, 3, 100);
        pointLight2.position.set(-30, 20, -30);
        scene.add(pointLight2);
        const pointLight3 = new THREE.PointLight(0xffc0cb, 2.5, 80);
        pointLight3.position.set(0, 40, 20);
        scene.add(pointLight3);

        // Eventos
        setTimeout(() => { const info = document.getElementById('info'); if (info) info.style.opacity = '0'; }, 5000);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.resolution.set(window.innerWidth, window.innerHeight);
            lensingPass.uniforms.aspectRatio.value = window.innerWidth / window.innerHeight;
            renderer.setPixelRatio(isMobile ? 1 : 1.5);
        });

        const clock = new THREE.Clock();
        const blackHoleScreenPosVec3 = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const deltaTime = clock.getDelta();
           
            time += 0.01;
           
            diskMaterial.uniforms.uTime.value = elapsedTime;
            starMaterial.uniforms.uTime.value = elapsedTime;
            eventHorizonMat.uniforms.uTime.value = elapsedTime;
            eventHorizonMat.uniforms.uCameraPosition.value.copy(camera.position);
            blackHoleScreenPosVec3.copy(blackHoleMesh.position).project(camera);
            lensingPass.uniforms.blackHoleScreenPos.value.set(
                (blackHoleScreenPosVec3.x + 1) / 2,
                (blackHoleScreenPosVec3.y + 1) / 2
            );
           
            controls.update();
           
            stars.rotation.y += deltaTime * 0.003;
            accretionDisk.rotation.z += deltaTime * 0.005;

            // Animaciones románticas
            particles.forEach(particle => {
                particle.position.y -= particle.userData.velocity;
                particle.rotation.z += particle.userData.rotationSpeed;
               
                particle.userData.swing += particle.userData.swingSpeed;
                particle.position.x += Math.sin(particle.userData.swing) * 0.12;
                particle.position.z += Math.cos(particle.userData.swing * 0.7) * 0.08;
                if (particle.position.y < -80) {
                    particle.position.y = 150;
                    particle.position.x = Math.random() * 120 - 60;
                    particle.position.z = Math.random() * 120 - 60;
                }
            });
            imageParticles.forEach(particle => {
                particle.position.y -= particle.userData.velocity;
                particle.rotation.z += particle.userData.rotationSpeed;
               
                particle.userData.swing += particle.userData.swingSpeed;
                particle.position.x += Math.sin(particle.userData.swing) * 0.12;
                particle.position.z += Math.cos(particle.userData.swing * 0.7) * 0.08;
                if (particle.position.y < -80) {
                    particle.position.y = 150;
                    particle.position.x = Math.random() * 120 - 60;
                    particle.position.z = Math.random() * 120 - 60;
                }
            });
            hearts.forEach(heart => {
                heart.userData.angle += heart.userData.speed;
                heart.position.x = Math.cos(heart.userData.angle) * heart.userData.radius;
                heart.position.z = Math.sin(heart.userData.angle) * heart.userData.radius;
               
                heart.userData.floatOffset += heart.userData.floatSpeed;
                heart.position.y += Math.sin(heart.userData.floatOffset) * 0.15;
               
                heart.rotation.z = Math.sin(time + heart.userData.floatOffset) * 0.15;
            });
           
            composer.render(deltaTime);
        }
        animate();

        // Simular carga simple sin base de datos
        const loading = document.getElementById('loading');
        const progress = document.getElementById('progress');
        const status = document.getElementById('status');
        let progressValue = 0;
        const progressInterval = setInterval(() => {
            progressValue += Math.random() * 10;
            if (progressValue > 100) progressValue = 100;
            progress.style.width = progressValue + '%';
            if (progressValue >= 100) {
                clearInterval(progressInterval);
                loading.classList.add('hidden');
                setTimeout(() => {
                    loading.style.display = 'none';
                }, 500);
                status.textContent = 'Modo por defecto';
                status.style.color = '#ff00ff';
            }
        }, 100);
    </script>
</body>
</html>
