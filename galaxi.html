<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Singularity RomÃ¡ntico</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono:wght@400;700&family=Georgia:ital@0;1&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #100518 0%, #020104 70%);
            color: #00ffcc;
            font-family: 'Share Tech Mono', monospace;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 105, 180, 0.9);
            font-family: 'Georgia', serif;
            font-size: 22px;
            font-style: italic;
            letter-spacing: 1px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 0 8px rgba(255, 105, 180, 0.7), 0 0 12px rgba(255, 105, 180, 0.5), 2px 2px 4px rgba(0,0,0,0.8);
            transition: opacity 2s ease-in-out 1s;
            background: linear-gradient(135deg, rgba(255, 20, 147, 0.3), rgba(138, 43, 226, 0.3));
            padding: 20px 40px;
            border-radius: 25px;
            border: 2px solid rgba(255, 182, 193, 0.4);
            backdrop-filter: blur(10px);
            margin: 0 20px;
        }
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        #info {
            animation: float 3s ease-in-out infinite;
        }
        @media (max-width: 640px) {
            #info { font-size: 18px; top: 15px; padding: 15px 30px; }
            #info span {
                font-size: 11px !important;
            }
            .progress-bar { width: 250px; }
            #status { font-size: 10px; padding: 6px; }
        }
        /* Estilos para la carga */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #100518 0%, #020104 70%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            transition: opacity 0.5s ease-out;
        }
        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .progress-bar {
            width: 300px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ffcc;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 150;
            font-family: 'Share Tech Mono', monospace;
            border: 1px solid #00ffcc;
        }
    </style>
</head>
<body>
    <div id="info">
        <br>
        <span style="font-size: 14px; opacity: 0.8; font-family: 'Share Tech Mono', monospace;">Puedes hacer zoom en la pantalla para ver la magia</span>
    </div>
    <div id="status">Verificando...</div>
    <div id="loading">
        <div style="color: #ff00ff; font-size: 24px; margin-bottom: 20px;">Cargando Galaxia de Amor...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
    </div>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
      }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;

        // ConfiguraciÃ³n de la singularidad cyberpunk (fondo)
        const BLACK_HOLE_RADIUS = 1.3;
        const DISK_INNER_RADIUS = BLACK_HOLE_RADIUS + 0.2;
        const DISK_OUTER_RADIUS = 8.0;
        const DISK_TILT_ANGLE = Math.PI / 3.0;

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020104, 0.035);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000);
        camera.position.set(isMobile ? -12 : -6.5, isMobile ? 8 : 5.0, isMobile ? 12 : 6.5);

        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(isMobile ? 1 : 1.5);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            isMobile ? 0.4 : 0.6, 0.7, 0.2
        );
        composer.addPass(bloomPass);

        const lensingShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "blackHoleScreenPos": { value: new THREE.Vector2(0.5, 0.5) },
                "lensingStrength": { value: 0.12 }, "lensingRadius": { value: 0.3 },
                "aspectRatio": { value: window.innerWidth / window.innerHeight },
                "chromaticAberration": { value: 0.015 }, "scanlineIntensity": { value: 0.0 },
                "vignetteDarkness": { value: 0.8 }
            },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `
                uniform sampler2D tDiffuse; uniform vec2 blackHoleScreenPos; uniform float lensingStrength;
                uniform float lensingRadius; uniform float aspectRatio; uniform float chromaticAberration;
                uniform float scanlineIntensity; uniform float vignetteDarkness; varying vec2 vUv;
                void main() {
                    vec2 screenPos = vUv; vec2 toCenter = screenPos - blackHoleScreenPos;
                    toCenter.x *= aspectRatio; float dist = length(toCenter);
                    float distortionAmount = lensingStrength / (dist * dist + 0.003);
                    distortionAmount = clamp(distortionAmount, 0.0, 0.7);
                    float falloff = smoothstep(lensingRadius, lensingRadius * 0.3, dist);
                    distortionAmount *= falloff; vec2 offset = normalize(toCenter) * distortionAmount;
                    offset.x /= aspectRatio; vec2 distortedUvR = screenPos - offset * (1.0 + chromaticAberration);
                    vec2 distortedUvG = screenPos - offset; vec2 distortedUvB = screenPos - offset * (1.0 - chromaticAberration);
                    float r = texture2D(tDiffuse, distortedUvR).r; float g = texture2D(tDiffuse, distortedUvG).g;
                    float b = texture2D(tDiffuse, distortedUvB).b; vec3 finalColor = vec3(r, g, b);
                    float scanline = sin(vUv.y * 800.0) * 0.5 + 0.5;
                    finalColor.rgb -= scanline * scanlineIntensity * finalColor.rgb;
                    float vignette = length(vUv - vec2(0.5)); finalColor *= (1.0 - vignette * vignetteDarkness);
                    gl_FragColor = vec4(finalColor, 1.0);
                }`
        };
        const lensingPass = new ShaderPass(lensingShader);
        composer.addPass(lensingPass);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.035;
        controls.rotateSpeed = 0.4; controls.autoRotate = false;
        controls.autoRotateSpeed = 0.1; controls.target.set(0, 0, 0);
        controls.minDistance = 2.5; controls.maxDistance = 100;
        controls.enablePan = false;
        controls.update();

        // Elementos de la galaxia cyberpunk (fondo)
        const starGeometry = new THREE.BufferGeometry();
        const starCount = isMobile ? 80000 : 150000;
        const starPositions = new Float32Array(starCount * 3);
        const starColors = new Float32Array(starCount * 3);
        const starSizes = new Float32Array(starCount);
        const starTwinkle = new Float32Array(starCount);
        const starFieldRadius = 2000;
        const starPalette = [
            new THREE.Color(0x00ffff), new THREE.Color(0xff00ff),
            new THREE.Color(0x8A2BE2), new THREE.Color(0x00ff7f),
            new THREE.Color(0xccddff),
        ];
        for (let i = 0; i < starCount; i++) {
            const i3 = i * 3;
            const phi = Math.acos(-1 + (2 * i) / starCount);
            const theta = Math.sqrt(starCount * Math.PI) * phi;
            const radius = Math.cbrt(Math.random()) * starFieldRadius + 100;
            starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
            starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            starPositions[i3 + 2] = radius * Math.cos(phi);
            const starColor = starPalette[Math.floor(Math.random() * starPalette.length)].clone();
            starColor.multiplyScalar(Math.random() * 0.7 + 0.3);
            starColors[i3] = starColor.r; starColors[i3 + 1] = starColor.g; starColors[i3 + 2] = starColor.b;
            starSizes[i] = THREE.MathUtils.randFloat(0.8, 2.5);
            starTwinkle[i] = Math.random() * Math.PI * 2;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
        starGeometry.setAttribute('twinkle', new THREE.BufferAttribute(starTwinkle, 1));

        const starMaterial = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uPixelRatio: { value: renderer.getPixelRatio() } },
            vertexShader: `
                uniform float uTime; uniform float uPixelRatio;
                attribute float size; attribute float twinkle;
                varying vec3 vColor; varying float vTwinkle;
                void main() {
                    vColor = color; vTwinkle = sin(uTime * 2.5 + twinkle) * 0.5 + 0.5;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * uPixelRatio * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }`,
            fragmentShader: `
                varying vec3 vColor; varying float vTwinkle;
                void main() {
                    float dist = distance(gl_PointCoord, vec2(0.5));
                    float cross = abs(gl_PointCoord.x - 0.5) + abs(gl_PointCoord.y - 0.5);
                    if (cross > 0.5) discard;
                    float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                    alpha *= (0.2 + vTwinkle * 0.8);
                    gl_FragColor = vec4(vColor, alpha);
                }`,
            transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        const eventHorizonGeom = new THREE.SphereGeometry(BLACK_HOLE_RADIUS * 1.05, 128, 64);
        const eventHorizonMat = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uCameraPosition: { value: camera.position } },
            vertexShader: `
                varying vec3 vNormal; varying vec3 vPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal); vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform float uTime; uniform vec3 uCameraPosition;
                varying vec3 vNormal; varying vec3 vPosition;
                void main() {
                    vec3 viewDirection = normalize(uCameraPosition - vPosition);
                    float fresnel = 1.0 - abs(dot(vNormal, viewDirection));
                    fresnel = pow(fresnel, 2.0); vec3 glowColor = vec3(0.0, 1.0, 0.8);
                    float pulse = sin(uTime * 3.5) * 0.2 + 0.8;
                    gl_FragColor = vec4(glowColor * fresnel * pulse, fresnel * 0.5);
                }`,
            transparent: true, blending: THREE.AdditiveBlending, side: THREE.BackSide
        });
        const eventHorizon = new THREE.Mesh(eventHorizonGeom, eventHorizonMat);
        scene.add(eventHorizon);

        const blackHoleGeom = new THREE.SphereGeometry(BLACK_HOLE_RADIUS, 128, 64);
        const blackHoleMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const blackHoleMesh = new THREE.Mesh(blackHoleGeom, blackHoleMat);
        blackHoleMesh.renderOrder = 0;
        scene.add(blackHoleMesh);

        // Create heart-shaped disk
        function createHeartShape(scale, offsetX, offsetY) {
            const shape = new THREE.Shape();
            shape.moveTo(offsetX + 5 * scale, offsetY + 5 * scale);
            shape.bezierCurveTo(offsetX + 5 * scale, offsetY + 5 * scale, offsetX + 4 * scale, offsetY, offsetX, offsetY);
            shape.bezierCurveTo(offsetX - 6 * scale, offsetY, offsetX - 6 * scale, offsetY + 7 * scale, offsetX - 6 * scale, offsetY + 7 * scale);
            shape.bezierCurveTo(offsetX - 6 * scale, offsetY + 11 * scale, offsetX - 3 * scale, offsetY + 15.4 * scale, offsetX + 5 * scale, offsetY + 19 * scale);
            shape.bezierCurveTo(offsetX + 12 * scale, offsetY + 15.4 * scale, offsetX + 16 * scale, offsetY + 11 * scale, offsetX + 16 * scale, offsetY + 7 * scale);
            shape.bezierCurveTo(offsetX + 16 * scale, offsetY + 7 * scale, offsetX + 16 * scale, offsetY, offsetX + 10 * scale, offsetY);
            shape.bezierCurveTo(offsetX + 7 * scale, offsetY, offsetX + 5 * scale, offsetY + 5 * scale, offsetX + 5 * scale, offsetY + 5 * scale);
            return shape;
        }

        const outerScale = DISK_OUTER_RADIUS / 16;
        const innerScale = DISK_INNER_RADIUS / 16;
        const centerX = -5 * outerScale;
        const centerY = -9.5 * outerScale;

        const outerHeart = createHeartShape(outerScale, centerX, centerY);
        const innerHeart = createHeartShape(innerScale, -5 * innerScale + centerX * (innerScale / outerScale), -9.5 * innerScale + centerY * (innerScale / outerScale));
        outerHeart.holes.push(innerHeart);

        const diskGeometry = new THREE.ShapeGeometry(outerHeart);

        const diskMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0.0 }, uColorHot: { value: new THREE.Color(0xffffff) },
                uColorMid1: { value: new THREE.Color(0xff00ff) }, uColorMid2: { value: new THREE.Color(0x00ffff) },
                uColorOuter: { value: new THREE.Color(0x3939f5) }, uNoiseScale: { value: 3.5 },
                uFlowSpeed: { value: 0.25 }, uDensity: { value: 1.5 }
            },
            vertexShader: `
                varying vec2 vUv; varying float vRadius; varying float vAngle;
                void main() {
                    vUv = uv; vRadius = length(position.xy); vAngle = atan(position.y, position.x);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform float uTime; uniform vec3 uColorHot; uniform vec3 uColorMid1; uniform vec3 uColorMid2; uniform vec3 uColorOuter;
                uniform float uNoiseScale; uniform float uFlowSpeed; uniform float uDensity;
                varying vec2 vUv; varying float vRadius; varying float vAngle;
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                float snoise(vec3 v) {
                    const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx);
                    vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy);
                    vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy;
                    i = mod289(i); vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                    float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_); vec4 x = x_ * ns.x + ns.yyyy; vec4 y = y_ * ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw);
                    vec4 s0 = floor(b0) * 2.0 + 1.0; vec4 s1 = floor(b1) * 2.0 + 1.0; vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
                    vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
                    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
                    m = m * m; return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
                }
                void main() {
                    float normalizedRadius = smoothstep(${DISK_INNER_RADIUS.toFixed(2)}, ${DISK_OUTER_RADIUS.toFixed(2)}, vRadius);
                    float timeOffset = uTime * uFlowSpeed * (2.0 / (vRadius * 0.3 + 1.0));
                    vec2 noiseUv = vec2(vAngle * 2.0 + timeOffset, vRadius * 0.5);
                    float noiseVal1 = snoise(vec3(noiseUv * uNoiseScale, uTime * 0.15));
                    float noiseVal2 = snoise(vec3(noiseUv * uNoiseScale * 2.0 + 0.8, uTime * 0.22));
                    float noiseVal = (noiseVal1 * 0.6 + noiseVal2 * 0.4); noiseVal = (noiseVal + 1.0) * 0.5;
                    vec3 color = mix(uColorOuter, uColorMid2, smoothstep(0.0, 0.4, normalizedRadius));
                    color = mix(color, uColorMid1, smoothstep(0.3, 0.7, normalizedRadius));
                    color = mix(color, uColorHot, smoothstep(0.65, 0.95, normalizedRadius));
                    float brightness = pow(1.0 - normalizedRadius, 1.2) * 3.0 + 0.5;
                    brightness *= (0.3 + noiseVal * 2.2);
                    float radialGrid = 1.0 - (sin(vRadius * 3.0 - uTime * 0.5) * 0.5 + 0.5);
                    radialGrid = pow(radialGrid, 4.0); float angleGrid = 1.0 - (sin(vAngle * 20.0) * 0.5 + 0.5);
                    angleGrid = pow(angleGrid, 4.0); float grid = 1.0 - clamp(radialGrid + angleGrid, 0.0, 1.0);
                    brightness *= (0.7 + grid * 0.8); float alpha = uDensity * (0.2 + noiseVal * 0.9);
                    alpha *= smoothstep(0.0, 0.15, normalizedRadius); alpha *= (1.0 - smoothstep(0.85, 1.0, normalizedRadius));
                    alpha = clamp(alpha, 0.0, 1.0); gl_FragColor = vec4(color * brightness, alpha);
                }`,
            transparent: true, side: THREE.DoubleSide, depthWrite: false, blending: THREE.AdditiveBlending
        });
        const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
        accretionDisk.rotation.x = DISK_TILT_ANGLE;
        accretionDisk.renderOrder = 1;
        scene.add(accretionDisk);

        const gridHelper = new THREE.GridHelper(100, 50, 0x00ffff, 0x00ffff);
        gridHelper.material.opacity = 0.1;
        gridHelper.material.transparent = true;
        gridHelper.material.blending = THREE.AdditiveBlending;
        gridHelper.position.y = -10;
        scene.add(gridHelper);

        // Elementos romÃ¡nticos (frente) - Adaptados a la escena
        let particles = [];
        let imageParticles = [];
        let hearts = [];
        let time = 0;
        const romanticEmojis = ['ðŸ’•', 'ðŸ’–', 'ðŸ’—', 'ðŸ’“', 'ðŸ’', 'ðŸ’˜', 'ðŸ’ž', 'â¤ï¸', 'ðŸ–¤', 'ðŸ¤',
                                'ðŸ’œ', 'ðŸ©·', 'â£ï¸'];
        const romanticPhrases = [
            'Te amo', 'Te quiero', 'Eres mi todo', 'Mi amor', 'Para siempre',
            'Juntos', 'Mi vida', 'Amor eterno', 'Mi cielo', 'Contigo',
            'Forever', 'Mi corazÃ³n', 'Te adoro', 'Mi mundo', 'Amor mÃ­o',
            'Eres Ãºnico', 'Mi tesoro', 'Te necesito', 'Mi alma', 'Solo tÃº'
        ];
        const romanticColors = [0xff1493, 0xff69b4, 0xffc0cb, 0xffb6c1, 0xff85c1,
                                0xda70d6, 0xee82ee, 0xdda0dd, 0xf0e68c, 0xffd700];

        function createRomanticParticle() {
            const size = isMobile ? 100 : 140;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const isEmoji = Math.random() > 0.4;
           
            if (isEmoji) {
                ctx.shadowBlur = isMobile ? 20 : 30;
                ctx.shadowColor = 'rgba(255, 105, 180, 1.0)';
                ctx.font = `bold ${isMobile ? 70 : 100}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(romanticEmojis[Math.floor(Math.random() * romanticEmojis.length)], size / 2, size / 2);
            } else {
                ctx.shadowBlur = isMobile ? 15 : 25;
                ctx.shadowColor = 'rgba(255, 182, 193, 1.0)';
               
                const gradient = ctx.createLinearGradient(0, 0, size, size);
                gradient.addColorStop(0, '#' + romanticColors[Math.floor(Math.random() * romanticColors.length)].toString(16).padStart(6, '0'));
                gradient.addColorStop(1, '#' + romanticColors[Math.floor(Math.random() * romanticColors.length)].toString(16).padStart(6, '0'));
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);
               
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = isMobile ? 15 : 25;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.font = `italic bold ${isMobile ? 18 : 28}px Georgia, serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
               
                const phrase = romanticPhrases[Math.floor(Math.random() * romanticPhrases.length)];
                const words = phrase.split(' ');
               
                if (words.length > 2) {
                    ctx.fillText(words[0] + ' ' + words[1], size / 2, size * 0.43);
                    ctx.fillText(words.slice(2).join(' '), size / 2, size * 0.64);
                } else if (words.length === 2) {
                    ctx.fillText(words[0], size / 2, size * 0.43);
                    ctx.fillText(words[1], size / 2, size * 0.64);
                } else {
                    ctx.font = `italic bold ${isMobile ? 22 : 34}px Georgia, serif`;
                    ctx.fillText(phrase, size / 2, size / 2);
                }
               
                ctx.font = `${isMobile ? 18 : 25}px Arial`;
                ctx.shadowBlur = 8;
                ctx.fillText('ðŸ’•', size / 2, size * 0.82);
            }
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(material);
            sprite.position.x = Math.random() * 120 - 60;
            sprite.position.y = Math.random() * 100 + 80;
            sprite.position.z = Math.random() * 120 - 60;
            const scale = isMobile ? (Math.random() * 4 + 3) : (Math.random() * 8 + 6);
            sprite.scale.set(scale, scale, 1);
            sprite.userData = {
                velocity: Math.random() * 0.05 + 0.02,
                rotationSpeed: (Math.random() - 0.5) * 0.02,
                swing: Math.random() * Math.PI * 2,
                swingSpeed: Math.random() * 0.02 + 0.015
            };
            scene.add(sprite);
            particles.push(sprite);
        }

        function createImageParticle() {
            if (typeof window.customImages === 'undefined' || window.customImages.length === 0) return;
            const size = isMobile ? 100 : 140;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, size, size);
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(material);
            sprite.position.x = Math.random() * 120 - 60;
            sprite.position.y = Math.random() * 100 + 80;
            sprite.position.z = Math.random() * 120 - 60;
            const scale = isMobile ? (Math.random() * 4 + 3) : (Math.random() * 8 + 6);
            sprite.scale.set(scale, scale, 1);
            sprite.userData = {
                velocity: Math.random() * 0.05 + 0.02,
                rotationSpeed: (Math.random() - 0.5) * 0.02,
                swing: Math.random() * Math.PI * 2,
                swingSpeed: Math.random() * 0.02 + 0.015,
                imgIndex: Math.floor(Math.random() * window.customImages.length)
            };
            sprite.material.map = window.customImages[sprite.userData.imgIndex];
            sprite.material.needsUpdate = true;
            scene.add(sprite);
            imageParticles.push(sprite);
        }

        window.createImages = function() {
            const imageCount = isMobile ? 5 : 10;
            for (let i = 0; i < imageCount; i++) {
                createImageParticle();
            }
        };

        function createFloatingHeart() {
            const size = isMobile ? 70 : 100;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.shadowBlur = isMobile ? 20 : 35;
            ctx.shadowColor = 'rgba(255, 20, 147, 1)';
            ctx.font = `bold ${isMobile ? 55 : 80}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ðŸ’–', size / 2, size / 2);
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(material);
            const angle = Math.random() * Math.PI * 2;
            const radius = 40 + Math.random() * 20;
            sprite.position.x = Math.cos(angle) * radius;
            sprite.position.y = Math.random() * 40 - 20;
            sprite.position.z = Math.sin(angle) * radius;
            const scale = isMobile ? (Math.random() * 4 + 3) : (Math.random() * 8 + 6);
            sprite.scale.set(scale, scale, 1);
            sprite.userData = {
                angle: angle,
                radius: radius,
                speed: 0.003 + Math.random() * 0.002,
                floatSpeed: Math.random() * 0.03 + 0.015,
                floatOffset: Math.random() * Math.PI * 2
            };
            scene.add(sprite);
            hearts.push(sprite);
        }

        function createMagicalStars() {
            const starCount = isMobile ? 1500 : 3000;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            for (let i = 0; i < starCount; i++) {
                vertices.push(
                    Math.random() * 500 - 250,
                    Math.random() * 500 - 250,
                    Math.random() * 500 - 250
                );
               
                const color = new THREE.Color();
                color.setHex(romanticColors[Math.floor(Math.random() * romanticColors.length)]);
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
           
            const material = new THREE.PointsMaterial({
                size: isMobile ? 1.5 : 2.0,
                transparent: true,
                opacity: 1.0,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
           
            const romanticStars = new THREE.Points(geometry, material);
            scene.add(romanticStars);
        }

        // Crear elementos romÃ¡nticos
        const particleCount = isMobile ? 200 : 400;
        const heartCount = isMobile ? 25 : 50;
        for (let i = 0; i < particleCount; i++) {
            createRomanticParticle();
        }
        for (let i = 0; i < heartCount; i++) {
            createFloatingHeart();
        }
        createMagicalStars();
        window.customImages = [];
        window.createImages();

        // Luces romÃ¡nticas
        const ambientLight = new THREE.AmbientLight(0xffe4f0, 0.6);
        scene.add(ambientLight);
        const pointLight1 = new THREE.PointLight(0xff1493, 3, 100);
        pointLight1.position.set(30, 30, 30);
        scene.add(pointLight1);
        const pointLight2 = new THREE.PointLight(0xda70d6, 3, 100);
        pointLight2.position.set(-30, 20, -30);
        scene.add(pointLight2);
        const pointLight3 = new THREE.PointLight(0xffc0cb, 2.5, 80);
        pointLight3.position.set(0, 40, 20);
        scene.add(pointLight3);

        // Eventos
        setTimeout(() => { const info = document.getElementById('info'); if (info) info.style.opacity = '0'; }, 5000);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.resolution.set(window.innerWidth, window.innerHeight);
            lensingPass.uniforms.aspectRatio.value = window.innerWidth / window.innerHeight;
            renderer.setPixelRatio(isMobile ? 1 : 1.5);
        });

        const clock = new THREE.Clock();
        const blackHoleScreenPosVec3 = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const deltaTime = clock.getDelta();
           
            time += 0.01;
           
            diskMaterial.uniforms.uTime.value = elapsedTime;
            starMaterial.uniforms.uTime.value = elapsedTime;
            eventHorizonMat.uniforms.uTime.value = elapsedTime;
            eventHorizonMat.uniforms.uCameraPosition.value.copy(camera.position);
            blackHoleScreenPosVec3.copy(blackHoleMesh.position).project(camera);
            lensingPass.uniforms.blackHoleScreenPos.value.set(
                (blackHoleScreenPosVec3.x + 1) / 2,
                (blackHoleScreenPosVec3.y + 1) / 2
            );
           
            controls.update();
           
            stars.rotation.y += deltaTime * 0.003;
            accretionDisk.rotation.z += deltaTime * 0.005;

            // Animaciones romÃ¡nticas
            particles.forEach(particle => {
                particle.position.y -= particle.userData.velocity;
                particle.rotation.z += particle.userData.rotationSpeed;
               
                particle.userData.swing += particle.userData.swingSpeed;
                particle.position.x += Math.sin(particle.userData.swing) * 0.12;
                particle.position.z += Math.cos(particle.userData.swing * 0.7) * 0.08;
                if (particle.position.y < -80) {
                    particle.position.y = 150;
                    particle.position.x = Math.random() * 120 - 60;
                    particle.position.z = Math.random() * 120 - 60;
                }
            });
            imageParticles.forEach(particle => {
                particle.position.y -= particle.userData.velocity;
                particle.rotation.z += particle.userData.rotationSpeed;
               
                particle.userData.swing += particle.userData.swingSpeed;
                particle.position.x += Math.sin(particle.userData.swing) * 0.12;
                particle.position.z += Math.cos(particle.userData.swing * 0.7) * 0.08;
                if (particle.position.y < -80) {
                    particle.position.y = 150;
                    particle.position.x = Math.random() * 120 - 60;
                    particle.position.z = Math.random() * 120 - 60;
                }
            });
            hearts.forEach(heart => {
                heart.userData.angle += heart.userData.speed;
                heart.position.x = Math.cos(heart.userData.angle) * heart.userData.radius;
                heart.position.z = Math.sin(heart.userData.angle) * heart.userData.radius;
               
                heart.userData.floatOffset += heart.userData.floatSpeed;
                heart.position.y += Math.sin(heart.userData.floatOffset) * 0.15;
               
                heart.rotation.z = Math.sin(time + heart.userData.floatOffset) * 0.15;
            });
           
            composer.render(deltaTime);
        }
        animate();

        // Simular carga simple sin base de datos
        const loading = document.getElementById('loading');
        const progress = document.getElementById('progress');
        const status = document.getElementById('status');
        let progressValue = 0;
        const progressInterval = setInterval(() => {
            progressValue += Math.random() * 10;
            if (progressValue > 100) progressValue = 100;
            progress.style.width = progressValue + '%';
            if (progressValue >= 100) {
                clearInterval(progressInterval);
                loading.classList.add('hidden');
                setTimeout(() => {
                    loading.style.display = 'none';
                }, 500);
                status.textContent = 'Modo por defecto';
                status.style.color = '#ff00ff';
            }
        }, 100);
    </script>
</body>
</html>
